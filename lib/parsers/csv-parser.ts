import Papa from 'papaparse';
import type { CSVRow, Lead } from '@/types';

export function parseGoogleMapsCSV(file: File): Promise<Lead[]> {
    return new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            complete: (results) => {
                try {
                    const normalized = (results.data as CSVRow[]).map(normalizeLead);
                    resolve(normalized);
                } catch (error) {
                    reject(error);
                }
            },
            error: (error) => {
                reject(error);
            },
        });
    });
}

function cleanPhoneNumber(phone: string | undefined): string {
    if (!phone) return '';
    // Remove all non-digit characters except +
    return phone.replace(/[^\d+]/g, '');
}

function normalizeLead(row: CSVRow): Lead {
    const now = new Date().toISOString();

    return {
        id: '', // Will be generated by database
        business_name: row['Business Name'] || row['Name'] || row['business_name'] || row['name'] || 'Unknown Business',
        phone_number: cleanPhoneNumber(
            row['Phone'] || row['Phone Number'] || row['phone'] || row['phone_number']
        ),
        address: row['Address'] || row['address'] || '',
        category: row['Category'] || row['Type'] || row['category'] || row['type'] || '',
        website: row['Website'] || row['URL'] || row['website'] || row['url'] || null,
        rating: parseFloat(row['Rating'] || row['rating'] || '0') || null,
        raw_data: row, // Keep original for reference
        status: 'pending',
        potential_level: 'not_assessed',
        assigned_to: null,
        current_agent_id: null,
        locked_at: null,
        created_at: now,
        updated_at: now,
        processed_at: null,
        batch_id: null,
    };
}

export function validateCSVStructure(file: File): Promise<boolean> {
    return new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: true,
            preview: 1, // Only parse first row to check headers
            complete: (results) => {
                const headers = results.meta.fields || [];

                // Check if at least one of the required header variations exists
                const hasBusinessName = headers.some(h =>
                    h.toLowerCase().includes('business') ||
                    h.toLowerCase().includes('name')
                );

                const hasPhone = headers.some(h =>
                    h.toLowerCase().includes('phone')
                );

                if (hasBusinessName && hasPhone) {
                    resolve(true);
                } else {
                    resolve(false);
                }
            },
            error: (error) => {
                reject(error);
            },
        });
    });
}
